import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,b as n,o as e}from"./app-A7uZLuxm.js";const l={};function t(h,s){return e(),a("div",null,s[0]||(s[0]=[n(`<br><p><img src="http://cdn.leemuzi.com/weblog/jiyu.png" style="zoom:10%;">作者寄语：</p><p>树型结构是一种重要的非线性数据结构。其中以树和二叉树最为常用。树是以分支关系定义的层次结构，是一种一对多的数据结构。</p><h2 id="树的定义和基本术语" tabindex="-1"><a class="header-anchor" href="#树的定义和基本术语"><span>树的定义和基本术语</span></a></h2><h3 id="定义" tabindex="-1"><a class="header-anchor" href="#定义"><span>定义</span></a></h3><p>树（Tree）是n（n≥0）个结点的有限集。在任意一个非空树中：（1）<strong>有且仅有一个</strong>特定的根（Root）结点；（2）当n&gt;1的时候，其余结点可分为m（m≥0）个<strong>互不相交</strong>的有限集T<sub>1</sub>，T<sub>2</sub>...T<sub>n</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250317221226201.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="结点的分类" tabindex="-1"><a class="header-anchor" href="#结点的分类"><span>结点的分类</span></a></h3><p>树的结点包含一个数据元素及若干指向其子树的分支。结点拥有的<strong>子树数</strong>称为结点的度（Degree）。度为0的结点称为<strong>叶子节点（Leaf）或终端结点</strong>；度不为0的结点称为<strong>非终端结点或分支结点</strong>。除根节点外，分支结点也称为内部节点。树的度就是<strong>树内各结点的度的最大值</strong>。</p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250317224035805.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="结点间的关系" tabindex="-1"><a class="header-anchor" href="#结点间的关系"><span>结点间的关系</span></a></h3><p>结点的子树的根节点称为该结点的<strong>孩子结点</strong>（Child），该节点称为孩子结点的<strong>双亲结点</strong>（Parent），同一个双亲结点之间互称为<strong>兄弟结点</strong>（Sibling），结点的<strong>祖先</strong>是从根节点到该节点所经分支上的所有结点，以某节点为根的子树中的任一结点都成为该节点的<strong>子孙</strong>。</p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250318221905846.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="结点的层次" tabindex="-1"><a class="header-anchor" href="#结点的层次"><span>结点的层次</span></a></h3><p>结点的<strong>层次</strong>（Level）从根定义开始，根为第一层，根的孩子为第二层。若某节点在第L层，则其子树是在第L+1层。其双亲在同一层的结点互称为堂兄弟，树中结点的<strong>最大层次称为树的深度或高度。</strong></p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250318224849473.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树是<strong>有序树</strong>，否则称为无序树。上图就是一个有序树。</p><p><strong>森林（Forest）</strong> 是m（m≥0）棵不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250318230715975.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="树的抽象数据类型" tabindex="-1"><a class="header-anchor" href="#树的抽象数据类型"><span>树的抽象数据类型</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ADT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Tree {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    数据对象：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        D </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {N</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> E}，其中 N 是节点的集合，E 是边的集合。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    数据关系：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        R </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> {</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> child</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;"> |</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> child ∈ N}，表示父子关系。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    基本操作：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        InitTree</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">T)：初始化树。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        DestroyTree</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">T)：销毁树。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        TreeEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T)：判断树是否为空。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        Root</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T)：返回树的根节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        Parent</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node)：返回节点的父节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        FirstChild</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node)：返回节点的第一个子节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        NextSibling</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node)：返回节点的下一个兄弟节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        InsertChild</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node)：插入子节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        DeleteChild</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> parent</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> i)：删除子节点。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        PreOrderTraverse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visit)：前序遍历。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        InOrderTraverse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visit)：中序遍历。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        PostOrderTraverse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visit)：后序遍历。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        LevelOrderTraverse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> visit)：层次遍历。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        TreeDepth</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T)：返回树的深度。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        TreeSize</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T)：返回树的节点总数。</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        IsLeaf</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(T</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node)：判断节点是否为叶子节点。</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="树的链式存储结构" tabindex="-1"><a class="header-anchor" href="#树的链式存储结构"><span>树的链式存储结构</span></a></h3><p>双亲表示法：假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器指示其双亲结点在数组中的位置。</p><p>孩子表示法：把每个结点的孩子结点排列起来，以单链表作为存储结构，则n个结点有n个孩子链表，如果是叶子节点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放在一维数组中。</p><p>孩子兄弟表示法：任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的，因此可以设置两个指针分别指向该节点的第一个孩子和此节点的右兄弟。</p><h2 id="二叉树" tabindex="-1"><a class="header-anchor" href="#二叉树"><span>二叉树</span></a></h2><h3 id="定义-1" tabindex="-1"><a class="header-anchor" href="#定义-1"><span>定义</span></a></h3><p>二叉树（Binary Tree）是一种比较特殊的树形结构，它的特点是每个结点至多只有两棵子树（即二叉树中不存在度大于2的结点），并且，二叉树的子树是有左右之分的，其次序不能任意颠倒。</p><figure><img src="http://cdn.leemuzi.com/weblog/image-20250319223309799.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="二叉树的抽象数据类型" tabindex="-1"><a class="header-anchor" href="#二叉树的抽象数据类型"><span>二叉树的抽象数据类型</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ADT</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> BinaryTree {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    数据：</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        节点集合：{node1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> node2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> nodeN}</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">        根节点：root</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    操作：</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        initTree</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 初始化二叉树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        isEmpty</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 判断二叉树是否为空</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        getRoot</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 获取根节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        getLeft</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 获取左子节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        getRight</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 获取右子节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        insertLeft</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 插入左子节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        insertRight</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> value)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 插入右子节点</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        deleteLeft</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 删除左子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        deleteRight</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(node)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 删除右子树</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        traverse</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">(mode)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> 遍历二叉树</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,31)]))}const r=i(l,[["render",t],["__file","tree.html.vue"]]),d=JSON.parse('{"path":"/notes/structure/tree.html","title":"树和二叉树","lang":"zh-CN","frontmatter":{"title":"树和二叉树","order":3,"author":"李木子","category":["数据结构"],"tag":["树","二叉树"],"description":"作者寄语： 树型结构是一种重要的非线性数据结构。其中以树和二叉树最为常用。树是以分支关系定义的层次结构，是一种一对多的数据结构。 树的定义和基本术语 定义 树（Tree）是n（n≥0）个结点的有限集。在任意一个非空树中：（1）有且仅有一个特定的根（Root）结点；（2）当n>1的时候，其余结点可分为m（m≥0）个互不相交的有限集T1，T2...Tn，其...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/notes/structure/tree.html"}],["meta",{"property":"og:site_name","content":"李木子"}],["meta",{"property":"og:title","content":"树和二叉树"}],["meta",{"property":"og:description","content":"作者寄语： 树型结构是一种重要的非线性数据结构。其中以树和二叉树最为常用。树是以分支关系定义的层次结构，是一种一对多的数据结构。 树的定义和基本术语 定义 树（Tree）是n（n≥0）个结点的有限集。在任意一个非空树中：（1）有且仅有一个特定的根（Root）结点；（2）当n>1的时候，其余结点可分为m（m≥0）个互不相交的有限集T1，T2...Tn，其..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"http://cdn.leemuzi.com/weblog/image-20250317221226201.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-20T13:34:41.000Z"}],["meta",{"property":"article:author","content":"李木子"}],["meta",{"property":"article:tag","content":"树"}],["meta",{"property":"article:tag","content":"二叉树"}],["meta",{"property":"article:modified_time","content":"2025-03-20T13:34:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"树和二叉树\\",\\"image\\":[\\"http://cdn.leemuzi.com/weblog/image-20250317221226201.png\\",\\"http://cdn.leemuzi.com/weblog/image-20250317224035805.png\\",\\"http://cdn.leemuzi.com/weblog/image-20250318221905846.png\\",\\"http://cdn.leemuzi.com/weblog/image-20250318224849473.png\\",\\"http://cdn.leemuzi.com/weblog/image-20250318230715975.png\\",\\"http://cdn.leemuzi.com/weblog/image-20250319223309799.png\\"],\\"dateModified\\":\\"2025-03-20T13:34:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"李木子\\"}]}"]]},"headers":[{"level":2,"title":"树的定义和基本术语","slug":"树的定义和基本术语","link":"#树的定义和基本术语","children":[{"level":3,"title":"定义","slug":"定义","link":"#定义","children":[]},{"level":3,"title":"结点的分类","slug":"结点的分类","link":"#结点的分类","children":[]},{"level":3,"title":"结点间的关系","slug":"结点间的关系","link":"#结点间的关系","children":[]},{"level":3,"title":"结点的层次","slug":"结点的层次","link":"#结点的层次","children":[]},{"level":3,"title":"树的抽象数据类型","slug":"树的抽象数据类型","link":"#树的抽象数据类型","children":[]},{"level":3,"title":"树的链式存储结构","slug":"树的链式存储结构","link":"#树的链式存储结构","children":[]}]},{"level":2,"title":"二叉树","slug":"二叉树","link":"#二叉树","children":[{"level":3,"title":"定义","slug":"定义-1","link":"#定义-1","children":[]},{"level":3,"title":"二叉树的抽象数据类型","slug":"二叉树的抽象数据类型","link":"#二叉树的抽象数据类型","children":[]}]}],"git":{"createdTime":1742477681000,"updatedTime":1742477681000,"contributors":[{"name":"lee","username":"lee","email":"li15237845367@163.com","commits":1,"url":"https://github.com/lee"}]},"readingTime":{"minutes":4.44,"words":1332},"filePathRelative":"notes/structure/tree.md","localizedDate":"2025年3月20日","excerpt":"<br>\\n<p><img src=\\"http://cdn.leemuzi.com/weblog/jiyu.png\\" style=\\"zoom:10%;\\">作者寄语：</p>\\n<p>树型结构是一种重要的非线性数据结构。其中以树和二叉树最为常用。树是以分支关系定义的层次结构，是一种一对多的数据结构。</p>\\n<h2>树的定义和基本术语</h2>\\n<h3>定义</h3>\\n<p>树（Tree）是n（n≥0）个结点的有限集。在任意一个非空树中：（1）<strong>有且仅有一个</strong>特定的根（Root）结点；（2）当n&gt;1的时候，其余结点可分为m（m≥0）个<strong>互不相交</strong>的有限集T<sub>1</sub>，T<sub>2</sub>...T<sub>n</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p>","autoDesc":true}');export{r as comp,d as data};
