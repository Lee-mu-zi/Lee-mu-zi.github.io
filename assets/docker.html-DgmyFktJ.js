import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,e as l,o}from"./app-Bm65cE-4.js";const a="/assets/jiyu.png",r="/assets/tools/docker-intro/registry-reposotory.png",t="/assets/tools/docker-desktop/Snipaste_2025-02-24_22-42-31.png",c="/assets/tools/docker-desktop/Snipaste_2025-03-01_21-36-11.png",n="/assets/tools/docker-desktop/Snipaste_2025-03-01_21-59-12.png",d="/assets/tools/docker-desktop/Snipaste_2025-03-01_22-00-49.png",p="/assets/tools/docker-desktop/Snipaste_2025-03-01_22-05-06.png",k={};function h(m,e){return o(),i("div",null,e[0]||(e[0]=[l('<br><p><img src="'+a+'" style="zoom:10%;">作者寄语：</p><p>概念是一个老生常谈的话题，每次学一个新的技术，总是避免不开前面繁琐复杂的概念环节，虽然概念这些东西比较乏味，但是不得不说，概念有时候对我们还真的会出现很大的帮助。不过关于Docker的概念性的东西并不多，大多还是需要去手动实践的。</p><br><h2 id="docker是什么" tabindex="-1"><a class="header-anchor" href="#docker是什么"><span>Docker是什么</span></a></h2><p>Docker是一种开源的<strong>容器化平台</strong>，用于开发、部署和运行应用程序。通过将应用程序与其依赖项（如库、配置文件等）打包到一个轻量级的、独立的运行环境中，也就是容器。实现了应用程序的快速部署和跨环境的一致性。</p><h2 id="镜像-image" tabindex="-1"><a class="header-anchor" href="#镜像-image"><span>镜像（Image）</span></a></h2><p>是一个轻量级、独立、可执行的软件包，包含了运行应用程序所需的所有内容，如代码、运行时环境、库、环境变量和配置文件。它是 Docker 容器的基础，容器则是镜像的运行实例。<br> 镜像有两个重要的原则：</p><ul><li>镜像是不可变的，镜像一旦被创建就无法修改。只能添加新的镜像或则在其基础上修改。</li><li>镜像由多层组成，每层代表一个指令（如安装软件、添加文件），这些层只读且可共享，提升了存储和传输效率。</li></ul><h2 id="容器-container" tabindex="-1"><a class="header-anchor" href="#容器-container"><span>容器（Container）</span></a></h2><p>容器是每个应用程序组件的独立进程。每个组件（前端 React 应用程序、Python API 引擎和数据库）都在自己的隔离环境中运行，与计算机上的其他所有组件完全隔离。越来越多的人喜欢用Docker的主要原因还是因为它的</p><ul><li>每个容器都拥有其运行所需要的一切，不依赖于主机上预安装的任何依赖项。</li><li>容器是独立运行的，它们对主机和其他容器的影响最小，提高了应用程序的安全性。</li><li>每个容器都是独立管理的，删除一个容器并不会影响到其他的容器。</li><li>容器可以在任何地方运行。</li></ul><h3 id="docker容器的特点" tabindex="-1"><a class="header-anchor" href="#docker容器的特点"><span>Docker容器的特点</span></a></h3><p>容器的目的和虚拟机是一样的，都是为了创建一个隔离环境。</p><ul><li>轻量化：一台主机上运行的多个Docker容器可以共享主机操作系统内核；启动迅速，只需占用很少的计算和内存资源。</li><li>标准开放：Docker容器基于开放式标准，能够在多有主流Linux版本、Windows以及VM、裸机服务器和云在内的任何基础设施上运行。</li><li>安全可靠：Docker赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker默认提供最强的隔离，因此应用出现问题，也是单个容器的问题，而不会涉及到整台主机。</li></ul><h2 id="注册表-registry" tabindex="-1"><a class="header-anchor" href="#注册表-registry"><span>注册表（Registry）</span></a></h2><p>Docker Registry 是一个用于存储、管理和分发 Docker 镜像的服务。它是 Docker 生态系统的核心组件之一，允许用户上传（push）和下载（pull）镜像。Docker Registry 可以是公共的（如 Docker Hub）或私有的（自建或云服务提供的 Registry）。</p><h3 id="仓库-repository" tabindex="-1"><a class="header-anchor" href="#仓库-repository"><span>仓库（Repository）</span></a></h3><p>Registry是存储和管理容器镜像的集中位置，是 Docker Registry 中的一个逻辑单元，用于存储和管理同一项目的不同版本的镜像。每个仓库包含一组相关的镜像，这些镜像通过标签（Tag）来区分。每个Repository包含一个或多个容器镜像。两者的关系如下图所示<br><img src="'+r+'" style="zoom:100%;"></p><h2 id="docker命令" tabindex="-1"><a class="header-anchor" href="#docker命令"><span>Docker命令</span></a></h2><p>了解过Docker历史的应该都知道，Docker最开始是没有可视化界面段的，主要是依赖于命令行工具（CLI）进行管理的<code>docker --help</code>命令可以查看Docker所有命令。如下图所示：<br><img src="'+t+'" style="zoom:80%;" title="部分命令展示"></p><h2 id="docker镜像相关命令" tabindex="-1"><a class="header-anchor" href="#docker镜像相关命令"><span>Docker镜像相关命令</span></a></h2><p><code>docker search [OPTIONS] TERM</code>：用于在Docker Hub中搜索Docker镜像。</p><ul><li><code>TERM</code>关键字或者镜像名称</li><li><code>OPTIONS</code>可选参数，用于定制搜索行为，可通过<code>docker search --help</code>查看参数详细信息</li></ul><p><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code>：用于从镜像仓库中拉取镜像到本地。</p><ul><li><code>NAME</code>：镜像的名称，如：nginx、mysql。</li><li><code>TAG</code>：镜像的标签，如：latest或1.23.1，默认拉取的是镜像仓库中的latest。</li><li><code>DIGEST</code>：镜像的摘要（唯一标识符），用于拉取特定版本的镜像。</li></ul><p><code>docker images [OPTIONS] [REPOSITORY[:TAG]]</code>和<code>docker image ls [OPTIONS] [REPOSITORY[:TAG]]</code>两者都是列出本地Docker镜像的命令，它们的功能完全相同，根据习惯自行选择。</p><ul><li><code>REPOSITORY</code>：指定镜像的仓库名称</li><li><code>TAG</code>：指定镜像的标签</li></ul><p><code>docker rmi [OPTIONS] IMAGE [IMAGE...]</code>和<code>docker image rm [OPTIONS] IMAGE [IMAGE...]</code>这两个命令都是删除本地镜像</p><ul><li><code>IMAGE</code>：要删除的镜像，可以通过镜像 ID、仓库名称（REPOSITORY）或标签（TAG）指定。</li></ul><h2 id="docker容器相关命令" tabindex="-1"><a class="header-anchor" href="#docker容器相关命令"><span>Docker容器相关命令</span></a></h2><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>用于从镜像创建并启动一个新的容器，它结合了<code>docker create</code>和<code>docker start</code>的功能</p><ul><li><code>IMAGE</code>：要运行的镜像名称或 ID。</li><li><code>COMMAND</code>：容器启动后执行的命令</li><li><code>ARG</code>：传递给命令的参数</li></ul><p><code>docker ps [OPTIONS]</code>是Docker CLI中用于列出正在运行的容器的命令。它可以帮助查看当前运行的容器状态、端口映射、容器名称等信息。如果需要查看所有容器（包括已停止的容器），可以使用<code>docker ps -a</code>。</p><p><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code>用于在正在运行的容器中执行命令，允许你在不进入容器的情况下，直接在容器内运行命令。这对于调试、管理容器或执行一次性任务非常有用。<code>docker exec -it</code>命令可以分配一个伪终端，类似于Linux，可以完善配置。</p><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li><li><code>COMMAND</code>：要在容器内执行的命令。</li><li><code>ARG</code>：传递给命令的参数。</li></ul><p><code>docker stop [OPTIONS] CONTAINER [CONTAINER...]</code>和<code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code>都可用于停止容器。</p><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li></ul><p><code>docker restart [OPTIONS] CONTAINER [CONTAINER...]</code>它会停止容器并重新启动</p><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li></ul><p><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code>用于删除一个或多个已停止的容器。</p><ul><li><code>CONTAINER</code>：目标容器的名称或 ID。</li></ul><h2 id="docker安装mysql" tabindex="-1"><a class="header-anchor" href="#docker安装mysql"><span>Docker安装MySQL</span></a></h2><h3 id="拉取镜像docker-pull-mysql-latest" tabindex="-1"><a class="header-anchor" href="#拉取镜像docker-pull-mysql-latest"><span>拉取镜像<code>docker pull mysql:latest</code></span></a></h3><img src="'+c+`" style="zoom:100%;"> ### 运行MySQL容器 使用以下命令能够启动一个MySQL容器 <div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mysql_container</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MYSQL_ROOT_PASSWORD=your_password</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 3306:3306</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  mysql</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数说明</p><ul><li><p><code>-d</code>：以后台模式运行容器。</p></li><li><p><code>--name mysql_container</code>：为容器指定一个名称（例如 mysql_container）。</p></li><li><p><code>-e MYSQL_ROOT_PASSWORD=your_password</code>：设置 MySQL 的 root 用户密码（将 your_password 替换为你的密码）。</p></li><li><p><code>-p 3306:3306</code>：将容器的 3306 端口映射到主机的 3306 端口。</p></li><li><p><code>mysql</code>：使用的镜像名称。<br> 运行结果<br><img src="`+n+'" style="zoom:100%;"><br> 运行完成后可以通过<code>docker ps -a</code>或<code>docker container ls -a</code>查询所有容器<br><img src="'+d+'" style="zoom:100%;"></p></li></ul><h3 id="连接mysql" tabindex="-1"><a class="header-anchor" href="#连接mysql"><span>连接MySQL</span></a></h3><p>容器创建成功之后就可以使用数据库工具连接，需要注意的是主机应该输入的应该是虚拟机的。<br><img src="'+p+`" style="zoom:100%;"></p><h3 id="管理mysql的配置文件" tabindex="-1"><a class="header-anchor" href="#管理mysql的配置文件"><span>管理MySQL的配置文件</span></a></h3><p>如果你需要自定义 MySQL 的配置文件（如 my.cnf），可以将配置文件挂载到容器中。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">docker</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> run</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -d</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  --name</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> mysql_container</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -e</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> MYSQL_ROOT_PASSWORD=your_password</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -p</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> 3306:3306</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  -v</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> /path/to/my.cnf:/etc/mysql/my.cnf</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>
<span class="line"><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">  mysql</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54)]))}const u=s(k,[["render",h],["__file","docker.html.vue"]]),D=JSON.parse('{"path":"/tools/docker/docker.html","title":"Docker概念","lang":"zh-CN","frontmatter":{"title":"Docker概念","cover":"/assets/tools/Docker.svg","order":1,"editLink":false,"description":"作者寄语： 概念是一个老生常谈的话题，每次学一个新的技术，总是避免不开前面繁琐复杂的概念环节，虽然概念这些东西比较乏味，但是不得不说，概念有时候对我们还真的会出现很大的帮助。不过关于Docker的概念性的东西并不多，大多还是需要去手动实践的。 Docker是什么 Docker是一种开源的容器化平台，用于开发、部署和运行应用程序。通过将应用程序与其依赖项...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/tools/docker/docker.html"}],["meta",{"property":"og:site_name","content":"李木子"}],["meta",{"property":"og:title","content":"Docker概念"}],["meta",{"property":"og:description","content":"作者寄语： 概念是一个老生常谈的话题，每次学一个新的技术，总是避免不开前面繁琐复杂的概念环节，虽然概念这些东西比较乏味，但是不得不说，概念有时候对我们还真的会出现很大的帮助。不过关于Docker的概念性的东西并不多，大多还是需要去手动实践的。 Docker是什么 Docker是一种开源的容器化平台，用于开发、部署和运行应用程序。通过将应用程序与其依赖项..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://mister-hope.github.io/assets/tools/Docker.svg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-22T10:37:03.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:src","content":"https://mister-hope.github.io/assets/tools/Docker.svg"}],["meta",{"name":"twitter:image:alt","content":"Docker概念"}],["meta",{"property":"article:modified_time","content":"2025-03-22T10:37:03.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Docker概念\\",\\"image\\":[\\"https://mister-hope.github.io/assets/tools/Docker.svg\\"],\\"dateModified\\":\\"2025-03-22T10:37:03.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"李木子\\",\\"url\\":\\"https://mister-hope.com\\"}]}"]]},"headers":[{"level":2,"title":"Docker是什么","slug":"docker是什么","link":"#docker是什么","children":[]},{"level":2,"title":"镜像（Image）","slug":"镜像-image","link":"#镜像-image","children":[]},{"level":2,"title":"容器（Container）","slug":"容器-container","link":"#容器-container","children":[{"level":3,"title":"Docker容器的特点","slug":"docker容器的特点","link":"#docker容器的特点","children":[]}]},{"level":2,"title":"注册表（Registry）","slug":"注册表-registry","link":"#注册表-registry","children":[{"level":3,"title":"仓库（Repository）","slug":"仓库-repository","link":"#仓库-repository","children":[]}]},{"level":2,"title":"Docker命令","slug":"docker命令","link":"#docker命令","children":[]},{"level":2,"title":"Docker镜像相关命令","slug":"docker镜像相关命令","link":"#docker镜像相关命令","children":[]},{"level":2,"title":"Docker容器相关命令","slug":"docker容器相关命令","link":"#docker容器相关命令","children":[]},{"level":2,"title":"Docker安装MySQL","slug":"docker安装mysql","link":"#docker安装mysql","children":[{"level":3,"title":"拉取镜像docker pull mysql:latest","slug":"拉取镜像docker-pull-mysql-latest","link":"#拉取镜像docker-pull-mysql-latest","children":[]},{"level":3,"title":"连接MySQL","slug":"连接mysql","link":"#连接mysql","children":[]},{"level":3,"title":"管理MySQL的配置文件","slug":"管理mysql的配置文件","link":"#管理mysql的配置文件","children":[]}]}],"git":{"createdTime":1740063494000,"updatedTime":1742639823000,"contributors":[{"name":"lee","username":"lee","email":"li15237845367@163.com","commits":9,"url":"https://github.com/lee"}]},"readingTime":{"minutes":6.36,"words":1909},"filePathRelative":"tools/docker/docker.md","localizedDate":"2025年2月20日","excerpt":"<br>\\n<p><img src=\\"/assets/jiyu.png\\" style=\\"zoom:10%;\\">作者寄语：</p>\\n<p>概念是一个老生常谈的话题，每次学一个新的技术，总是避免不开前面繁琐复杂的概念环节，虽然概念这些东西比较乏味，但是不得不说，概念有时候对我们还真的会出现很大的帮助。不过关于Docker的概念性的东西并不多，大多还是需要去手动实践的。</p>\\n<br>\\n<h2>Docker是什么</h2>\\n<p>Docker是一种开源的<strong>容器化平台</strong>，用于开发、部署和运行应用程序。通过将应用程序与其依赖项（如库、配置文件等）打包到一个轻量级的、独立的运行环境中，也就是容器。实现了应用程序的快速部署和跨环境的一致性。</p>","autoDesc":true}');export{u as comp,D as data};
